"""
Gaussian quadrature and shape function implementations for finite element analysis.
"""

import jax.numpy as jnp
from jax import jit
from functools import partial
from typing import Tuple

@partial(jit, static_argnums=(0,))
def gauss_triangle(n: int) -> Tuple[jnp.ndarray, jnp.ndarray]:
    """
    Get Gauss quadrature points and weights for triangular elements.
    
    Args:
        n: Number of quadrature points (2-10 supported)
        
    Returns:
        Tuple of (quadrature points, weights)
        
    Raises:
        ValueError: If n is not supported
    """
    if n == 2:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.666666666666667, 0.166666666666667]
        ])
        W = jnp.array([0.333333333333333, 0.333333333333333])
        
    elif n == 3:
        Q = jnp.array([
            [0.166666666666667, 0.166666666666667],
            [0.166666666666667, 0.666666666666667],
            [0.666666666666667, 0.166666666666667]
        ])
        W = jnp.array([0.166666666666667, 0.166666666666667, 0.166666666666667])
        
    elif n == 4:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.200000000000000, 0.200000000000000],
            [0.200000000000000, 0.600000000000000],
            [0.600000000000000, 0.200000000000000]
        ])
        W = jnp.array([-0.281250000000000, 0.260416666666667, 0.260416666666667, 0.260416666666667])
        
    elif n == 5:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.470142064105115, 0.470142064105115],
            [0.470142064105115, 0.059715871789770],
            [0.059715871789770, 0.470142064105115],
            [0.101286507323456, 0.101286507323456]
        ])
        W = jnp.array([0.225000000000000, 0.132394152788506, 0.132394152788506,
                       0.132394152788506, 0.125939180544827])

    elif n == 6:
        Q = jnp.array([
            [0.249286745170910, 0.249286745170910],
            [0.249286745170910, 0.501426509658180],
            [0.501426509658180, 0.249286745170910],
            [0.063089014491502, 0.063089014491502],
            [0.063089014491502, 0.873821971016996],
            [0.873821971016996, 0.063089014491502]
        ])
        W = jnp.array([0.116786275726379, 0.116786275726379, 0.116786275726379,
                       0.050844906370207, 0.050844906370207, 0.050844906370207])

    elif n == 7:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.059715871789770, 0.470142064105115],
            [0.470142064105115, 0.059715871789770],
            [0.470142064105115, 0.470142064105115],
            [0.101286507323456, 0.101286507323456],
            [0.101286507323456, 0.797426985353087],
            [0.797426985353087, 0.101286507323456]
        ])
        W = jnp.array([0.225000000000000, 0.132394152788506, 0.132394152788506,
                       0.132394152788506, 0.125939180544827, 0.125939180544827,
                       0.125939180544827])

    elif n == 8:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.081414823414554, 0.459292588292723],
            [0.459292588292723, 0.081414823414554],
            [0.459292588292723, 0.459292588292723],
            [0.658861384496478, 0.170569307751761],
            [0.170569307751761, 0.658861384496478],
            [0.170569307751761, 0.170569307751761],
            [0.898905543365938, 0.050547228317031]
        ])
        W = jnp.array([-0.149570044467670, 0.175615257433204, 0.175615257433204,
                       0.175615257433204, 0.053347235608839, 0.053347235608839,
                       0.053347235608839, 0.077113760890257])

    elif n == 9:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.020634961602525, 0.489682519198738],
            [0.489682519198738, 0.020634961602525],
            [0.489682519198738, 0.489682519198738],
            [0.125820817014127, 0.437089591492937],
            [0.437089591492937, 0.125820817014127],
            [0.437089591492937, 0.437089591492937],
            [0.623592928761935, 0.188203535619033],
            [0.188203535619033, 0.623592928761935]
        ])
        W = jnp.array([0.097135796282799, 0.031334700227139, 0.031334700227139,
                       0.031334700227139, 0.077827541004774, 0.077827541004774,
                       0.077827541004774, 0.079647738927210, 0.079647738927210])

    elif n == 10:
        Q = jnp.array([
            [0.333333333333333, 0.333333333333333],
            [0.028844733232685, 0.485577633383657],
            [0.485577633383657, 0.028844733232685],
            [0.485577633383657, 0.485577633383657],
            [0.781036849029926, 0.109481575485037],
            [0.109481575485037, 0.781036849029926],
            [0.109481575485037, 0.109481575485037],
            [0.141707219414880, 0.307939838764121],
            [0.307939838764121, 0.141707219414880],
            [0.307939838764121, 0.307939838764121]
        ])
        W = jnp.array([0.090817990382754, 0.036725957756467, 0.036725957756467,
                       0.036725957756467, 0.045321059435528, 0.045321059435528,
                       0.045321059435528, 0.072757916845420, 0.072757916845420,
                       0.072757916845420])
    else:
        raise ValueError('n must be between 2 and 10')
    
    return Q, W


@jit
def shape_functions(ksi: jnp.ndarray) -> Tuple[jnp.ndarray, jnp.ndarray]:
    """
    Compute shape functions and their derivatives.
    
    Args:
        ksi: Local coordinates
        
    Returns:
        Tuple of (shape functions, derivatives)
    """
    N = jnp.stack([(1 - ksi) / 2, (1 + ksi) / 2])
    dN = jnp.array([-1/2, 1/2])
    return N, dN

@jit
def basis_ksi_eta(ksi: float, eta: float) -> jnp.ndarray:
    """
    Compute basis function derivatives with respect to ksi and eta.
    
    Args:
        ksi: First local coordinate
        eta: Second local coordinate
        
    Returns:
        Array of basis function derivatives
    """
    return jnp.array([[-1, 1, 0],
                      [-1, 0, 1]])

@jit
def interpolation(ksi: float, eta: float) -> jnp.ndarray:
    """
    Compute interpolation functions.
    
    Args:
        ksi: First local coordinate
        eta: Second local coordinate
        
    Returns:
        Array of interpolation functions or basis functions
    """
    return jnp.array([1 - ksi - eta, ksi, eta])